#  [NOTE] 细说 Java 多线程之内存可见性

> keyword: `Java内存模型`
>
> date: 2018-07-17

> 慕课网[细说Java多线程之内存可见性](http://www.imooc.com/learn/352)、2018-07-17

- 什么是内存可见性
- Java内存模型（JMM）
- 实现可见性的方式：synchronized和volatile
- final也可以保证内存可见性
- synchronized和volatile实现内存可见性的原理

## 可见性

可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到

- 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量
- 线程的工作内存：

## Java内存模型（JMM）

JMM描述了JAVA程序中各种变量**（线程共享变量）**的访问规则，以及在JVM中将变量存储到内存和从内从中读取出变量这样的底层细节

- 所有的变量都存储在主内存中
- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）

### JMM两条规定

- **线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存读写**
- **不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成**

### 共享变量可见性实现的原理

线程1对共享变量的修改要想被线程2及时看到，必须要经过如下2个步骤：

- 把工作内存1中更新过的共享变量刷新到主内存中
- 将主内存中最新的共享变量的值更新到工作内存2中

```js
A 通过synchronized和volatile都可以实现可见性
// 解析：不同线程之间无法直接访问其他线程工作内存中的变量
B 不同线程之间可以直接访问其他线程工作内存中的变量
C 线程对共享变量的所有操作都必须在自己的工作内存中进行
D 所有的变量都存储在主内存中
```



# volatile 使用场合

- 对变量的写入操作不依赖其当前的值
  - 不满足:number++、count=count*5
  - 满足：boolean变量，记录温度变化的变量等
- 该变量没有包含在具有其他变量的不变式中
  - 不满足：不变式 low<up

## synchroinzed与volatile比较

- volatile不需要枷锁，比synchronized更轻量级，不会阻塞线程
- 从内存可见性角度讲，volatile读相当加锁，volatile写相当于解锁
- synchroinzed既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性 



对64位（long、double）变量的读写可能不是原子操作：

Java内存模型允许JVM将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行

导致问题：有可能会出现读取到“半个变量”的情况

解决办法：加volatile关键字

